# Default values for city-population Helm chart
# These can be overridden during deployment with --set or custom values file

# Application configuration
app:
  name: city-population-api
  replicaCount: 2  # Number of pod replicas for HA

  image:
    repository: city-population-api  # Docker image repository
    tag: "1.0.0"  # Image tag
    pullPolicy: IfNotPresent  # Pull image only if not present locally

  service:
    type: ClusterIP  # Internal service (use LoadBalancer for external access)
    port: 80  # Service port
    targetPort: 8000  # Container port

  resources:
    # Resource requests - guaranteed resources
    requests:
      memory: "128Mi"
      cpu: "100m"
    # Resource limits - maximum allowed resources
    limits:
      memory: "256Mi"
      cpu: "500m"

  # Liveness probe - checks if app is running
  livenessProbe:
    httpGet:
      path: /health
      port: 8000
    initialDelaySeconds: 15  # Wait before first probe
    periodSeconds: 10  # Probe every 10 seconds
    timeoutSeconds: 5
    failureThreshold: 3  # Restart after 3 failures

  # Readiness probe - checks if app is ready to serve traffic
  readinessProbe:
    httpGet:
      path: /health
      port: 8000
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3

  # Environment variables
  env:
    ELASTICSEARCH_HOST: "http://elasticsearch-master:9200"
    ELASTICSEARCH_INDEX: "cities"
    DEBUG: "false"

# Elasticsearch configuration (using official Elastic Helm chart)
elasticsearch:
  enabled: true  # Deploy Elasticsearch as part of this chart

  # Cluster configuration
  clusterName: "elasticsearch"
  nodeGroup: "master"

  # Single node setup for development (use 3+ for production)
  replicas: 1
  minimumMasterNodes: 1

  # Use HTTP protocol (not HTTPS) for development
  protocol: http
  createCert: false

  # Elasticsearch roles for this node group
  # For development: using minimal required roles
  # - master: cluster management
  # - data: store and search data
  # - ingest: document preprocessing (optional but useful)
  roles:
    - master
    - data
    - ingest

  # JVM heap size (should be ~50% of memory limit)
  esJavaOpts: "-Xmx1g -Xms1g"

  # Resource allocation
  resources:
    requests:
      cpu: "500m"
      memory: "2Gi"
    limits:
      cpu: "1000m"
      memory: "2Gi"

  # Persistent storage configuration
  volumeClaimTemplate:
    accessModes: [ "ReadWriteOnce" ]
    storageClassName: "standard"  # Use Minikube's standard storage class
    resources:
      requests:
        storage: 10Gi

  # Disable security for development (enable in production)
  esConfig:
    elasticsearch.yml: |
      xpack.security.enabled: false
      xpack.security.enrollment.enabled: false

  # Service configuration
  service:
    type: ClusterIP
    httpPort: 9200
    transportPort: 9300

# Ingress configuration (optional - for external access)
ingress:
  enabled: false  # Set to true to create ingress resource
  className: "nginx"  # Ingress controller class
  annotations: {}
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: city-api.example.com
      paths:
        - path: /
          pathType: Prefix
  tls: []
    # - secretName: city-api-tls
    #   hosts:
    #     - city-api.example.com

# Horizontal Pod Autoscaler (optional)
autoscaling:
  enabled: true  # Enable for automatic scaling based on metrics
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80
